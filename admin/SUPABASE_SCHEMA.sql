-- Run this in your Supabase SQL Editor to create the necessary table

create table site_content (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  key text unique not null,
  value text
);

-- Turn on Row Level Security
alter table site_content enable row level security;

-- Allow public read access (if you want content to be visible on the site)
create policy "Enable read access for all users"
on site_content for select
using (true);

-- Allow authenticated/anon users to insert/update (Adjust logic as needed for real security)
-- For a simple admin dashboard without auth implementation on the frontend side in this step,
-- you might need to allow anon updates OR set up Supabase Auth.
-- WARNING: The policy below allows ANYONE with the anon key to update data.
-- Ideally, you should implement Supabase Auth (Sign In) and restrict this to authenticated users.

create policy "Enable insert/update for all users"
on site_content for insert
with check (true);

create policy "Enable update for all users"
on site_content for update
using (true);

-- SALES TABLE
drop table if exists sales;
create table sales (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references auth.users not null default auth.uid(),
  user_email text not null,
  
  ref_num text unique not null,
  sale_date date default current_date not null,
  service_type text not null,
  affiliated_platform text,
  
  customer_name text not null,
  customer_details text,
  requirements text,
  
  b2b_price decimal(12,2) default 0,
  margin decimal(12,2) default 0,
  discount decimal(12,2) default 0,
  final_price decimal(12,2) generated always as (b2b_price + margin - discount) stored,
  
  advance_received decimal(12,2) default 0,
  adv_paid_to_b2b decimal(12,2) default 0,
  cust_direct_pay decimal(12,2) default 0,
  balance_to_receive decimal(12,2) generated always as (b2b_price + margin - discount - advance_received - cust_direct_pay) stored,
  
  payment_status text default 'payment pending', -- payment pending, advance received, full payment received, refund
  service_status text default 'pending', -- pending, issued, cancelled
  
  doc_num text, -- PNR, Ticket No, etc.
  remarks text,
  doc_link text
);

-- Note: In site_content table, we will store service types using key 'sales_service_types'
-- Default value: ["FLIGHT TKT", "BUS TKT", "room reservation", "travel insur.", "tour package", "Escort", "Property enlisting"]

-- Enable RLS
alter table sales enable row level security;

-- Policies
create policy "Users can see their own sales"
on sales for select
using (auth.uid() = user_id);

create policy "Admins can see all sales"
on sales for select
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin'))
  OR 
  (EXISTS (
    SELECT 1 FROM site_content 
    WHERE key = 'admin_users_registry' 
    AND value::jsonb @> format('[{"email": "%s", "role": "admin"}]', auth.jwt() ->> 'email')::jsonb
  ))
  OR
  (EXISTS (
    SELECT 1 FROM site_content 
    WHERE key = 'admin_users_registry' 
    AND value::jsonb @> format('[{"email": "%s", "role": "super_admin"}]', auth.jwt() ->> 'email')::jsonb
  ))
);

create policy "Users can insert their own sales" on sales for insert with check (auth.uid() = user_id);

create policy "Users can update their own sales" on sales for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

create policy "Admins can update any sale" on sales for update
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin'))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "admin"}]', auth.jwt() ->> 'email')::jsonb))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "super_admin"}]', auth.jwt() ->> 'email')::jsonb))
);

create policy "Admins can delete any sale" on sales for delete using (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin'));

-- USER EMAIL CONFIG TABLE
create table user_email_config (
  id uuid primary key default auth.uid(), -- One config per user
  user_email text not null,
  google_script_url text, -- The Web App URL from Apps Script
  sender_email text, -- The Alias to send from (must be configured in Gmail)
  status text default 'pending', -- pending, active, failed
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table user_email_config enable row level security;

-- Policies
create policy "Users can see their own config"
on user_email_config for select
using (auth.uid() = id);

create policy "Users can update their own config"
on user_email_config for insert
with check (auth.uid() = id);

create policy "Users can edit their own config"
on user_email_config for update
using (auth.uid() = id);
-- ENQUIRIES TABLE
create table enquiries (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  type text not null, -- 'contact', 'flight', 'taxi', etc.
  name text not null,
  email text,
  phone text,
  service text,
  subject text,
  message text,
  details jsonb, -- To store form-specific fields
  status text default 'new', -- new, read, replied, archived
  source_url text
);

-- Enable RLS
alter table enquiries enable row level security;

-- Policies
create policy "Enable insert for all users"
on enquiries for insert
with check (true);

create policy "Admins can see all enquiries"
on enquiries for select
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin'))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "admin"}]', auth.jwt() ->> 'email')::jsonb))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "super_admin"}]', auth.jwt() ->> 'email')::jsonb))
);

create policy "Admins can update enquiries"
on enquiries for update
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin'))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "admin"}]', auth.jwt() ->> 'email')::jsonb))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "super_admin"}]', auth.jwt() ->> 'email')::jsonb))
);

create policy "Admins can delete enquiries"
on enquiries for delete
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin'))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "super_admin"}]', auth.jwt() ->> 'email')::jsonb))
);

-- ANNOUNCEMENTS TABLE
create table announcements (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  start_date timestamp with time zone not null,
  end_date timestamp with time zone not null,
  target_roles text[] not null default '{}',
  subject text,
  body text,
  poster_url text,
  redirect_url text,
  created_by uuid references auth.users not null default auth.uid()
);

-- Enable RLS
alter table announcements enable row level security;

-- Policies
create policy "Enable read access for targeted roles"
on announcements for select
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' = ANY(target_roles))
  OR (auth.jwt() -> 'user_metadata' ->> 'role' IN ('super_admin', 'admin'))
);

create policy "Enable insert/update/delete for admins"
on announcements for all
using (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('super_admin', 'admin'))
);
-- TAXI VEHICLES TABLE
CREATE TABLE taxi_vehicles (
  vehicle_num text PRIMARY KEY, -- Use Vehicle Number as the ID
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
  owner_id uuid REFERENCES auth.users NOT NULL DEFAULT auth.uid(),
  owner_email text NOT NULL,
  
  name text NOT NULL,
  category text DEFAULT 'taxi', -- 'taxi' or 'bus'
  thumb_url text, -- Changed from key to URL
  is_enabled boolean DEFAULT true,
  is_approved boolean DEFAULT true,
  
  -- Rent details
  min_charge decimal(12,2) DEFAULT 0,
  charge_per_km decimal(12,2) DEFAULT 0,
  waiting_charge_per_hour decimal(12,2) DEFAULT 0,
  bata decimal(12,2) DEFAULT 0,
  
  details jsonb DEFAULT '{}'
);

ALTER TABLE taxi_vehicles ENABLE ROW LEVEL SECURITY;

-- Policies for taxi_vehicles
CREATE POLICY "Users can manage their own taxi vehicles" ON taxi_vehicles
FOR ALL USING (auth.uid() = owner_id);

CREATE POLICY "Admins can view and manage all taxi vehicles" ON taxi_vehicles
FOR ALL USING (
  (auth.jwt() -> 'user_metadata' ->> 'role' IN ('admin', 'super_admin', 'taxi_driver'))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "admin"}]', auth.jwt() ->> 'email')::jsonb))
  OR (EXISTS (SELECT 1 FROM site_content WHERE key = 'admin_users_registry' AND value::jsonb @> format('[{"email": "%s", "role": "super_admin"}]', auth.jwt() ->> 'email')::jsonb))
);

CREATE POLICY "Public can view enabled vehicles" ON taxi_vehicles
FOR SELECT USING (is_enabled = true);
